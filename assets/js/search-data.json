{
  
    
        "post0": {
            "title": "Add cross-referencing in your Research Papers and Pdfs created with MS Word",
            "content": "If you’re here, you’ve in all probability written the first draft of your paper and made a pdf for submission to your favorite journal/conference or open-access repository. Congratulations, pat yourself on the back, the hard part is now behind you. In a series of blog posts, I’m going to tell you how you can make your articles easier to read and understand and thus get more cited! . Okay! So why do we need in-text cross-referencing? . In-text cross referencing is useful whenever you want to make it easier for the reader to reach any position in the document like . Citations to you references in the bibliography section | Sections and sub-sections | Tables and Figures | Sometimes, page numbers (discouraged as it’s easy to overlook relevant page numbers that change at a later stage) | Any other position you wish to jump to | . Whenever we write a paper, we are spreading knowledge and it’s the duty of a good writer to make the journey as easy, fun and fulfilling for the reader as possible. A big way of doing this will be cross-referencing. . Word’s internal cross-referencing feature seems to be quite arcane and complicated to use if you’re using some reference manager like Mendeley or Zotero. In this day and age if you’re writing papers, you’re undoubtedly using some reference manager. I couldn’t find any easy way to get this internal cross-referencing to work. Hence I designed a hackish way to get this done in just a few simple steps. . Careful !? . You cannot easily modify these links, once created and modifying the citations with Mendeley or Zotero later will NOT update the cross-referencing, completely messing up your document. Hence please make sure you’re doing this as the absolute last stage of typesetting. . Also keep a saved copy, just in the off-chance, you really need to modify the reference list later. . Great! Tell me how to do it! . In this section, we’ll see how we can do cross-referencing for citations in a few simple steps . If you’re using any reference manager like Mendeley or Zotero, you’d have something called field-codes in your text. You can check it by pressing Alt+F9. If you see some weird text appearing, those are field codes and it’s recommended to remove them. Select your entire text by pressing Ctrl+A and then get rid of them by pressing Ctrl+Shift+F9 . | To make it easier to see all in-text citations within square-brackets, it’s ideal to highlight all of them and there’s an automated way to do this as well as described here with explanation. In the off-chance the link disappears, I’d reproduce those steps here: . a. Select all text with Ctrl+A. . b. Press Ctrl+H to open the Find and Replace dialog box. . c. Click the More button. . d. Select the Use wildcards check box an select All in the Search dropdown. . e. Put your cursor into the Find what field. . f. Type the following exactly (or copy it from here): ( [)(*)( ]) . g. Make sure the highlight option is NOT No color. . h. Click the Format button, and select Highlight. . i. Click on Replace All. . If your citations use parenthesis, instead of square-brackets, use ((*) ) in Step f. Why this works can be found here. This should select anything within parenthesis including non-citations like (D), please ignore those. This does work for compound references like (Author1 1993; Author2 and Author3 2017). Word has a bug where if a search fails, consequent searches might also fail, in that case, the best way is to restart the word processor saving the existing changes. . . Verify it all looks as expected and proceed. . | In your Bibliography/References section, click on the first reference, on the part [1], in between the brackets and press Ctrl+Shift+F5 to insert a bookmark. . | Name the reference r01(to later maintain order for upto 99 references easily) and press Enter. . | Repeat step 4 for all your references. . | Now select the text you want to link to originate from, say the number 1 between the square brackets, and click Ctrl+K, select Place in This Document in the left pane and click on the bookmark r01. Make sure text to display shows the selected text, ie. the number 1 here. . | Repeat Step 6 for all highlighted occurrences. For references like [17-19], add only one link from 17-19 to bookmark r17 and for [37-40,45], add one link from 37-40 to bookmark r37 and one from 45 to bookmark r45. . . | Remove all the highlights and probably the link decorations with blue fonts and underlines as well. Research papers have uniform font settings. So select Ctrl+A, remove the highlights, select the font color as Black and press Ctrl+U twice to remove underlines. . | Here we’ve primarily covered only cross-referencing citations with references, but this can be easily extended to sections, subsections, tables, figures or any other place in the document by bookmarking at that location with Ctrl+Shift+F5 , naming it and pressing Enter. Then just go to the place where the link should originate and press Ctrl+K and add the destination as the correct bookmark. I usually use the naming convention of r01... for references, f01... for figures, t01... for tables, s01... for sections and ss01... for sub-sections, but feel free to use any convention you want. . Here are some researchers and their Papers using this Method . A. J. Paul, “Randomised fast no-loss expert system to play tic-tac-toe like a human,” Cogn. Comput. Syst., Sep. 2020, doi: 10.1049/ccs.2020.0018. Click on the paper title to reach the ArXiv v2 of the paper typeset by the author, with this method. | . … and many more to come!! . Congratulations !! . You’ve made your first cross-referenced pdf in MS Word! Do note cross-referencing might not appear to work on some mobile pdf viewers even if it is enabled in the pdf, but does work on the Desktop, with Adobe, Google Chrome etc. . If you know such a free tool exists to do this for MS Word documents, do drop it in the comments, and we’d love to mention it here. In future, someone might create a script/macro for this, making it even easier. If you create that, or know someone who does, do reach out to us in the comments, we’d love to give it a shoutout and even go and make a post about it benefitting researchers across the globe. . Finally, if this article helped you, we’d love to hear about it in the comments and if you have used it in a paper, we’d love to feature your paper here as well. .",
            "url": "https://blog.carlresearch.org/research%20tips/research/paper%20formatting/2020/11/12/Add-cross-referencing-in-your-paper-pdfs-created-with-MS-Word.html",
            "relUrl": "/research%20tips/research/paper%20formatting/2020/11/12/Add-cross-referencing-in-your-paper-pdfs-created-with-MS-Word.html",
            "date": " • Nov 12, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "A Quick Overview of QUIC and HTTP/3",
            "content": "It’s quite evident how much we are dependent on the web. While some of us brag about being web developers, others are still intimidated by the information the web overflows us with. Ever wondered how the web works behind the scenes? . What really happens when you hit www.johndoe.com? . I’ll try to keep it as simple as possible, so here it goes— every domain name is associated with an IP address that the web understands. When you enter www.johndoe.com, it initially looks up for its IP address in the browser cache. If it is not found in browser cache, it looks up for it in the router cache and ISP cache. . . If the above steps don’t return the IP address, it is then requested to the root server which tells you from where you can get the information, i.e top level domain (TLD). The TLD let’s you know the IP address of your domain name (search input) and then you can initiate a connection with the domain. . . The connection is established in three steps and is known as TCP 3-way handshake. After successfully connecting with the server, you can then communicate with the domain and send requests according to your needs. . To understand the web, we have put some layers to how this awesome sequence works out. The Open Systems Interconnection (OSI) model acts as a reference tool for understanding communication and transfer of data between systems in a network. The OSI model comprises seven layers, each layer performing specific functions to support its neighboring layers. This layered stack basically provides flexibility, and hence these layers are quite loosely coupled. . . Physical Layer: It consists of physical devices such as hubs, repeaters, modems, etc. which are responsible for the transfer of raw unstructured data in the form of bits. It defines the topology of devices in a network and transmits data by converting the digital bits into electrical, optical, or radio signals. . | Data Link Layer: It comprises networking components such as NIC, Ethernet, etc. to ensure error-free transmission of data between the nodes in a network. It has two sub-layers, Medium Access Control (MAC) layer that helps in flow control and multiplexing of nodes over the network, and Logical Link Control (LLC) layer that provides flow and error control along with identification of network layer protocols. . | Network Layer: Devices like routers work at the network layer to assign the destination address in the packet headers. The routers are responsible for finding the optimal path from the available multiple paths to send the data to the desired destination. . | Transport Layer: This layer consists of protocols like Transmission Control Protocol (TCP) and User Datagram Protocol (UDP) that help in end-to-end delivery of data in the form of small units called segments. It is responsible for the sequencing and reassembling of segmented data along with error control. . | Session Layer: Implementations of session layer include Zone Information Protocol (ZIP) and Session Control Protocol (SCP) that make use of remote procedure calls (RPC). Session layer is responsible for the establishment, maintenance, authentication and security between end user application processes. . | Presentation Layer: Also known as syntax layer, it translates data into the form that the application accepts. It also assists in compression and encryption of the data if required by the application layer. Protocols like Secured Socket Layer (SSL) and File Transfer Protocol (FTP) are implemented at the presentation layer. . | Application Layer: This layer is the closest to the user and hence includes applications like Telnet and Simple Mail Transfer Protocol (SMTP). Application layer identifies resource availability, communication partners and synchronizes communication. Hence it acts as a window for application services to access the network and display the information received by lower layers to the user. . | . Before we understand what is QUIC, we need to understand what problems it solves. . HTTP 1 → HTTP 2 . If you’re using HTTP 1, your browser would be opening parallel connections to open up things at the same time. It doesn’t actually circumvent the head-of-line blocking problems, but surely makes them occur less frequently. It works well for the HTTP 1 but it certainly has its overheads, as it has to set-up as well as maintain all those numerous connections. By and large, HTTP 1 has three main issues: . TCP head-of-the-line blocking . | HTTP head-of-the-line blocking . | 4-RTT connection setup . | . If our connection set-up is slow, and we incur packet loss, other packets can be blocked even though they might have arrived at the client, and if we have a slow first resource on HTTP, then it can also block the things lined behind it. The last two have solutions inferred, but they themselves have a lot of overhead by itself. . The TLS 1.2 had made a total of 4 round trips in order to set up secured connections. To optimize this time trade-off, the simplest thing to do was to do two things in one round trip. It was possible to implement this in some scenarios of TLS 1.2 and was the default for TLS 1.3, its successor, having a total of 3 round trips. To optimize this even closer, the TCP and TLS could work together by pulling out some strings, and this technology was called TCP Fast Open, where the user could send some extra data in the initial SYN packet. This was also beneficial as we were able to achieve twice the performance that we initially had and now what really was needed was a holy grail, to perform everything in just one single task. Along with the TLS evolution, HTTP went under transformation too. From the journey of HTTP 1.1 to HTTP 2, it solved the head-of-the-line blocking problem as it became better and smarter. . Now after these amazing transformations, all we wish was the ability of HTTP to perform multiple things at once. This certainly wasn’t feasible on HTTP 1, as it sends all the information in one big block without any demarcation to which resources the individual blocks belong to. This was achieved by multiplexing. Hence, HTTP 2 solves two problems at once - the HTTP head-of-the-line blocking problem and the overhead of the mitigation as seen above. . Yet, the TCP head-of-the-line blocking problem in regards to the loss of packet isn’t resolved. However, it was observed that HTTP 2 can be 5 times slower than HTTP 1 on a network with packet traffic. By now, you might be thinking that this can be resolved by introducing a new version as in previous use cases. Yet we know that there exists no TCP 2.0 . The reason being, that TCP is too popular and widespread to be modified. According to the definitions of the Internet, we all know that it is an interconnection of several devices. Now, these devices are running on their own implementations of TCP. This means, that if we try to change these TCP implementations, there is a high probability that we break some of these middle-box implementations, and hence if we wish to modify these, we have to wait until all these humongous implementations have added support for it before we can actually deploy it at a large scale. . On the whole, in order to solve the TCP head-of-the-line problem, we can either wait for a whole another decade so that everyone is on the same boat, or, we can make a bold choice, that TCP isn’t evolvable anymore and hence needs a replacement. . Enter UDP . UDP isn’t like the TCP at all. It is fast and doesn’t care about the packet loss. . QUIC still uses TLS 1.3 . It still has that zero RTT goodness, it is built on top of UDP, and uses the HTTP 2 semantics. QUIC incorporates the multiplexing from HTTP 2 and re-implements in-order reliability on top of UDP custom top packet loss recovery logic. . This means that in QUIC if one packet is facing problems, others don’t have to be blocked due to it. Thus solving the TCP head-of-the-line problem! For solving this one problem, it is evident that a lot of effort is required at the backend. Also we know that HTTP 2 and TLS 1.3 work absolutely fine on TCP as well. So, the question arises: was it really worth the effort to solve that one TCP head-of-the-line blocking problem? The answer is NO. . Hence while developing QUIC, the developers strived to solve all the other problems as well. Consequently, QUIC is an amalgamation of everything one has known about networks over the past three decades. It’s like Christmas in a bowl! . Additional features of QUIC . Focuses on security . One of the major deviations of QUIC from the vulnerable TCP is its design goal of providing a secure-by-default transport protocol. QUIC achieves this by providing security features, like encryption and authentication, that are usually managed by higher layer protocols like TLS from the transport protocol itself. . Prevents middle box meddling through encryption . QUIC is more flexible than TCP and encrypts everything including its own metadata. Therefore the less these middle boxes get to see, the lesser they can modify. This is indeed useful for QUIC and its users, but not for the people who make these middle boxes. A lot of deliberation has been made just to come to a conclusion whether a single bit should be visible to the middle boxes or not. . Connection ID and multipath . It provides easy switching over networks. QUIC takes into account how people actually use the Internet in daily life, for say, when one is at home they are usually on WiFi, but once they step out, they switch to 4G. This closes down the TCP connection they would have established and reconnects as they now have a new IP address. However, in QUIC this is not so tiresome. QUIC instead assigns you a unique connection ID that remains the same irrespective of how many times you change your IP address. Icing on the cake, it also has the capability to use WiFi and 4G both at the same time; two networks along with extra bandwidth, which is the idea behind multipath) . Custom congestion control . It is the mechanism that prevents you from overloading the network by sending too much data. TCP has this feature as well, but it is not fairly optimal. It uses a single general-purpose algorithm and uses it for all types of connection. But it is not so generalized in case of QUIC. For instance, like a NETINFO API that lets you see what connection you’re currently using and how much bandwidth you have, it provides the perfect micro optimization for individual user and connection types for the exact moment, and even for the exact page one is trying to serve them, which makes HTTP 2 server push more practically applicable. . QUIC Performance Check . After the plethora of features that QUIC empowers us with, how much performance gain can we actually expect? And the answer is, WE DON’T KNOW! QUIC was originally developed by Google a couple of years ago. They initially deployed QUIC on their servers, and on Chrome, and is currently serving 7% of the total Internet space. QUIC hence has been battle-tested, but, only by Google. Google; the name eventually comes with trust. We like Google. If Google says something works, we say “standardize it”. This was the story of QUIC in a nutshell over past years. When we got the new IEFT version of QUIC, although it was similar to Google’s version in concept, yet it was changed to a great extent in terms of its implementation. There are several implementations of it, but none of them is even remotely ready for any type of performance testing, let alone browser integration. . Let’s talk numbers . According to Google, they found 3.6 - 8% improvement on an average over desktop and mobile devices. I’d be lying if I say I wasn’t disappointed by this. But these numbers represent an average. In 99% percentile, it shows an improvement of over 14-16%, which is indeed impactful. It might be quite evident by now that most of this improvement is due to the 0 RTT. But, one can see the 0 RTT only on servers that you’ve somehow seen/accessed before. When using mobile devices, one is likely to move around and hence Google load balances might send them to different data centers that they’ve never been before. This certainly justifies the unequal improvement rates over desktop and mobile devices. . Before you completely get all carried away in the numbers and wondering if QUIC really changed your life, let me recall for you why at the first place we switched to QUIC; and the answer is lossy networks, which is often misinterpreted as loss due to congestion. According to Google statistics, QUIC witnessed 20% less video buffering on contents in India. Another paper shows that there is a 14% of actual page load time improvement in the actual browser, which sounds pretty good. A conference paper tested QUIC with and without packet loss, and ofcourse QUIC is going to be comparatively slower with packet loss, but only 20% as compared to the 200% of HTTP/2 in most cases. Ok wow. But there are always two sides of a coin. You might be wondering why am I not citing other papers but quote the exact opposite results to the one cited till now. Well, hold your beer, here they come. There is one paper that says that QUIC is terrible for video streaming, with around 75% less Mbps than TCP for DASH streaming. Another conference paper says that if you have an inconsistent latency which causes packets to be re-ordered, QUIC is 100% than TCP. An old paper says that QUIC can have 30% slower page load time if it incurs packet loss and low bandwidth. . Conclusion . So where are we in terms of final QUIC and HTTP/3 deployment in the world? It is expected that we will see rapidly increased rollouts of QUIC and HTTP/3 by clients by the end 2020, as well as higher volume testing on pre-release channels. It will be followed by clients turning QUIC and HTTP/3 on in their stable releases. Furthermore, it is believed that QUIC and HTTP/3 will become the de-facto mainstream web protocol stack in 2021. . Further Reading . QUICHE . | Design and Internet scale deployemnt . | HTTP/3 Security . | . . Author . Shubhangi Singh . .",
            "url": "https://blog.carlresearch.org/quic%20%20http3/web/2020/11/10/A-Quick-Overview-of-QUIC-and-HTTP3.html",
            "relUrl": "/quic%20%20http3/web/2020/11/10/A-Quick-Overview-of-QUIC-and-HTTP3.html",
            "date": " • Nov 10, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "How sharp is your Memory? Check it with this Memory Game",
            "content": "Introduction . Hey! This is Sanskriti. Hope you all are doing well in this lockdown and using your time well to do productive things. So one of these days, my younger cousin wanted to play something with me, we were on a call. I remembered the memory game I used to play with my mom when I was a kid. My mom used to say the name of an object, I had to add one more object to the list, likewise we had to remember all the old objects in the list in the order and also add the new one. I started playing this game with my cousin but after some time, we both started forgetting the list and neither of us couldn’t point out the mistakes of each other, therefore we didn’t have a winner. So that day I decided to computerise this game with speech integration. This could solve two problems: . Computer’s memory is definitely better than human memory, so you won’t have to care about the right order to tally your responses with. . | If you don’t have a partner to play along with you, you could play it with the computer. So making the traditional memory game that we have been playing since childhood more interactive, fun and easy to play! . | . . Step 1: Generate random numbers and append them in a list . To develop this game, the first step was to automate the generation of random numbers that were supposed to be memorised by the player. So I wrote a script in python and used an inbuilt function randint() of the random module(available in the latest versions of python i.e, python 3 onwards). Here, I have given the code snippet to print the whole sequence of numbers, but in the actual game, I have printed only the last number of the list. Rest of the numbers stay in list for verification with the user’s input but are not printed. . import random while(f==0): #generate random number digit=random.randint(0,9) sequence.append(digit) print(sequence) . How are random integers generated? . Even the most random data generated with Python is not fully random in the scientific sense. It is pseudorandom, generated with a pseudorandom number generator (PRNG). It starts with a random number, known as the seed, and generates a pseudo-random sequence by performing some operation on that value. Each seed value will correspond to a sequence of generated values for a given random number generator. That is, if you provide the same seed twice, you get the same sequence of numbers twice. . The randint() function uses the Mersenne Twister PRNG algorithm and takes system current time as the seed so the value of seed keeps changing at every execution of the program. The randint() function can take two integer arguments , a start number and an end number, both inclusive. The function then generates numbers only in this range. . Step 2: Clear the output from screen . Next step was to clear the output (randomly-generated numbers) from the console after a few seconds for which I used time.stay() function from time library, again an in-built library in python and clear_output() function from IPython.display library. I added these two functions inside the while loop so that the old output gets cleared in every new level. . import time from IPython.display import clear_output while(f==0): #generate random number digit=random.randint(0,9) sequence.append(digit) print(sequence) time.sleep(2) clear_output(wait=True) . Step 3: Recognising speech . The most important step was to now integrate a speech recognition module with the game. For that, first you need to download the module, I did it using my pip installer. However, PyAudio Module is a dependency for the SpeechRecognition, and unfortunately you cannot download it directly using pip installer, you will need to use pipwin. After installing the modules, you need to create a function that can be reused to take the input from the user as and when required and compare it to the sequence we have already defined. I used speech recognition by Google API since it gives you the default API key for free. Therefore, an active internet connection is necessary throughout the game to play. . Special tip: Consider using a try and except block wherever possible so that if anything ever goes wrong, you have a chance to continue the script by returning the same function . Here, in the try block, I have typecasted the audio recognized as integer type, so that if due to some error in recognition, a string is recogised by the google cloud, the exception block would catch it and return the recogise() function again. . import speech_recognition as sr r = sr.Recognizer() def recognise(): with sr.Microphone() as source: print(&quot;Speak the number&quot;) audio = r.listen(source,timeout=3) try: s=int(sp) print(&quot;You said &quot;,s) return s except Exception as e: print(e) print(&quot;Didn&#39;t get you, can you say it again?&quot;) return recognise() . How is your voice recognized?? . Firstly, your speech is converted from physical sound to an electrical signal with a microphone, and then to digital data with an analog-to-digital converter. Then, powerful neural network models are used to transform the features and reduce the dimensionality of signals to simplify the speech. Voice activity detectors (VADs) are also used to reduce an audio signal to only the portions that are likely to contain speech. This prevents the recognizer from wasting time analyzing unnecessary parts of the signal. . In the modern speech recognition models like the Hidden Markov Model, the speech signal is divided into 10-millisecond fragments so that it can be approximated as a stationary process. The power spectrum of each fragment, (a plot of the signal’s power as a function of frequency) is mapped to a vector of real numbers known as cepstral coefficients. The final output of the HMM is a sequence of these vectors. . To decode the speech into text, groups of vectors are matched to one or more phonemes—a fundamental unit of speech. This calculation requires training, since the sound of a phoneme varies from speaker to speaker. A special algorithm is then applied to determine the most likely word (or words) that produce the given sequence of phonemes. . . Step 4: Making the computer interact with player . The last step was to make the game more interactive. So, I had used the pyttsx3 module. It is a module that converts string text into speech. You can also set the properties of th e computer voice using the function setproperty(), you can change several attributes of speech, male/female voice, speed, and many other things as per your requirements in a function. Next you directly need to call the function wherever you want in the program, passing the text to be spoken as an argument. . import pyttsx3 def speak(text): engine = pyttsx3.init() engine.setProperty(&#39;rate&#39;, 220) voices = engine.getProperty(&#39;voices&#39;) engine.setProperty(&#39;voice&#39;, voices[0].id) engine.say(text) engine.runAndWait() . Conclusion . Hope you enjoy building and playing this game. You can check my github repo github repo for the complete code. . Let me know how you renovate the game and take it forward. . Stay home, Stay safe and keep improving your memory! :) . Cheers, . Sanskriti Khare .",
            "url": "https://blog.carlresearch.org/speech%20recognition/python/pyttsx3/2020/08/20/how-sharp-is-your-memory.html",
            "relUrl": "/speech%20recognition/python/pyttsx3/2020/08/20/how-sharp-is-your-memory.html",
            "date": " • Aug 20, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "Contact",
          "content": "Where research meets dedication! .",
          "url": "https://blog.carlresearch.org/contact/",
          "relUrl": "/contact/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
      ,"page9": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://blog.carlresearch.org/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

  
  

}